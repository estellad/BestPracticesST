# Mouse coronal {#mouse_coronal}

This workflow analyzes a mouse coronal brain section dataset measured using the 10x Genomics Visium platform. This dataset was generated by 10x Genomics, and the raw data files are publicly available from the [10x Genomics website](https://support.10xgenomics.com/spatial-gene-expression/datasets/1.1.0/V1_Adult_Mouse_Brain).

The workflow follows the same steps as in the main chapters, with adaptations at several points for the characteristics of this dataset.


## Description of dataset {#mouse_coronal_dataset}

This dataset measures transcriptome-wide gene expression on a Visium slide spanning one hemisphere of a mouse coronal brain section. For experimental details, see the [10x Genomics website](https://support.10xgenomics.com/spatial-gene-expression/datasets/1.1.0/V1_Adult_Mouse_Brain).

Due to the small size of the mouse brain and the dimensions of the Visium slide (6.5mm x 6.5mm), the measurements span an entire brain hemisphere. Therefore, we can use this dataset to compare gene expression profiles between major anatomical regions of the mouse brain. In particular, we can can investigate spatial gradients of gene expression within major anatomical regions or cell types. (However, due to the resolution of the spots, each region is represented by only a relatively small number of spots, and it is not possible to resolve fine-grained anatomical or histological features such as cortical layers.)

Since cells in the mouse brain are relatively small, we also expect that most spots contain multiple cells. In this dataset, we do not know the exact numbers of cells per spot. (Estimating the numbers of cells per spot would require additional preprocessing using image segmentation algorithms, which we do not demonstrate here.)


## Load data

Load the dataset from the [STexampleData](https://github.com/lmweber/STexampleData) package. The data object is formatted in the `SpatialExperiment` object class defined in the [SpatialExperiment](https://bioconductor.org/packages/SpatialExperiment) package.

```{r load_data, message=FALSE}
library(STexampleData)
library(SpatialExperiment)

# load object
spe <- load_data("mouse_coronal")
spe
```


## Plot data

As an initial check, plot the spatial coordinates (spots) in x-y space on the tissue slide. This confirms that the object has loaded correctly, and the x-y dimensions match the orientation shown on the [10x Genomics website](https://support.10xgenomics.com/spatial-gene-expression/datasets/1.1.0/V1_Adult_Mouse_Brain).

Visualization functions are available in the [ggspavis](https://github.com/lmweber/ggpavis) package.

```{r plot_data, message=FALSE, fig.width=3.75, fig.height=3.75}
library(ggspavis)
library(ggplot2)

# plot spatial coordinates (spots)
plotSpots(spe)
```


## Quality control (QC)

Calculate spot-level QC metrics using the `scater` package [@McCarthy2017-zd]. Since mouse cells are small and most spots contain multiple cells, values are higher than for the human DLPFC dataset.

Since `SpatialExperiment` inherits from `SingleCellExperiment`, we can store QC metrics in `colData`.

```{r QC_calculate, message=FALSE}
library(scater)

# identify mitochondrial genes
is_mito <- grepl("(^MT-)|(^mt-)", rowData(spe)$gene_name)
table(is_mito)
rowData(spe)$gene_name[is_mito]

# calculate per-spot QC metrics
df <- perCellQCMetrics(spe, subsets = list(mito = is_mito))
head(df, 3)

# store per-spot QC metrics in object
spe <- addPerCellQC(spe, subsets = list(mito = is_mito))
```

Select filtering thresholds for the QC metrics by examining distributions (e.g. using histograms or other interactive visualizations).

```{r QC_thresholds, fig.width=7.5, fig.height=3}
# histograms of QC metrics
par(mfrow = c(1, 3))
hist(colData(spe)$sum, xlab = "sum", main = "Detected UMIs per spot")
hist(colData(spe)$detected, xlab = "detected", main = "Detected genes per spot")
hist(colData(spe)$subsets_mito_percent, xlab = "percent mitochondrial", main = "Percent mitochondrial UMIs")
par(mfrow = c(1, 1))

# select QC thresholds
qc_lib_size <- colData(spe)$sum < 5000
qc_detected <- colData(spe)$detected < 1000
qc_mito <- colData(spe)$subsets_mito_percent > 30

# number of discarded spots for each QC metric
apply(cbind(qc_lib_size, qc_detected, qc_mito), 2, sum)

# combined set of discarded spots
discard <- qc_lib_size | qc_detected | qc_mito
table(discard)

# store in object
colData(spe)$discard <- discard
```

Plot discarded spots in x-y coordinates on tissue slide, to check whether discarded spots are concentrated in any obvious biologically meaningful spatial regions (which would be problematic).

Visualization functions for QC purposes are available in the [spatzli](https://github.com/lmweber/spatzli) package.

```{r QC_check, message=FALSE, fig.width=3.75, fig.height=3.75}
library(spatzli)

# check spatial pattern of discarded spots
plotQCspots(spe, discard = "discard")
```

Some discarded spots are concentrated in a region at the top-left. However, after checking a reference map of a mouse coronal brain section, this region does not appear to correspond to any specific anatomical regions of interest. We assume that these are failed spots, and that removing them will not confound our downstream analyses.

We proceed to filter out the low-quality spots from the data object.

```{r QC_filter}
# filter low-quality spots
spe <- spe[, !colData(spe)$discard]
dim(spe)
```


## Normalization

Calculate log-transformed normalized counts, using pool-based size factors and deconvolution to the spot level, using `scater` [@McCarthy2017-zd] and `scran` [@Lun2016-dn]. Since we have a single sample, there are no blocking factors in the experimental design.

```{r normalization, message=FALSE, fig.height=4}
library(scran)

# quick clustering for pool-based size factors
set.seed(123)
qclus <- quickCluster(spe)
table(qclus)

# calculate size factors and store in object
spe <- computeSumFactors(spe, cluster = qclus)

summary(sizeFactors(spe))
hist(log10(sizeFactors(spe)), xlab = "log10 (size factors)", main = "Size factors")

# calculate logcounts (log-transformed normalized counts) and store in object
spe <- logNormCounts(spe)

assayNames(spe)
```


## Feature selection

Select top highly variable genes (HVGs) to identify cell types. We use methods from `scran` [@Lun2016-dn], and first filter out mitochondrial genes (since these are very highly expressed and not of biological interest here).

```{r feature_selection_mito}
# remove mitochondrial genes
spe <- spe[!is_mito, ]
dim(spe)
```

```{r feature_selection_HVGs, message=FALSE, fig.height=5}
# fit mean-variance relationship
dec <- modelGeneVar(spe)

# visualize mean-variance relationship
fit <- metadata(dec)
plot(fit$mean, fit$var, 
     xlab = "mean of log-expression", ylab = "variance of log-expression")
curve(fit$trend(x), col = "dodgerblue", add = TRUE, lwd = 2)

# select top HVGs
top_hvgs <- getTopHVGs(dec, prop = 0.1)
length(top_hvgs)
```

Note there are a few extremely highly expressed genes, which influence the fitted mean-variance relationship. We identify these genes to check whether they should be removed as outliers.

```{r outliers}
# identify outlier genes
rev(sort(fit$mean))[1:3]
outlier_ids <- names(rev(sort(fit$mean))[1:3])

rowData(spe)[outlier_ids, ]
```

These appear to be biologically meaningful genes, so we leave them in.


## Dimensionality reduction

Calculate principal component analysis (PCA) using `scater` [@McCarthy2017-zd], and retain top 50 principal components (PCs) for downstream analyses. Also calculate UMAP on the top 50 PCs, and retain top 2 UMAP components for visualization.

```{r dimensionality_reduction_PCA}
# calculate PCA
set.seed(123)
spe <- runPCA(spe, subset_row = top_hvgs)

reducedDimNames(spe)
dim(reducedDim(spe, "PCA"))
```

```{r dimensionality_reduction_UMAP}
# calculate UMAP on top 50 PCs
set.seed(123)
spe <- runUMAP(spe, dimred = "PCA")

reducedDimNames(spe)
dim(reducedDim(spe, "UMAP"))

# update column names for plotting
colnames(reducedDim(spe, "UMAP")) <- paste0("UMAP", 1:2)
```


## Clustering

Perform clustering (on top 50 PCs calculated on top HVGs) to identify cell types. We use graph-based clustering with the Walktrap method from `scran` [@Lun2016-dn].

```{r clustering_calculate}
# graph-based clustering
set.seed(123)
k <- 10
g <- buildSNNGraph(spe, k = k, use.dimred = "PCA")
g_walk <- igraph::cluster_walktrap(g)
clus <- g_walk$membership
table(clus)

# store cluster labels in object (column "label")
colLabels(spe) <- factor(clus)
```

Plot clusters in (i) x-y coordinates of the tissue slide, and (ii) UMAP coordinates.

Here we use the visualization functions from the [ggspavis](https://github.com/lmweber/ggpavis) package.

```{r clustering_plots, fig.height=4.5, fig.width=5.5}
# define custom color palette
colors <- unname(palette.colors(palette = "Polychrome 36"))

# plot clusters in x-y coordinates
plotSpots(spe, discrete = "label", palette = colors)

# plot clusters in UMAP space
plotDimRed(spe, type = "UMAP", discrete = "label", palette = colors)
```

